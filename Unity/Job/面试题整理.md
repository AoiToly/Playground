# 面试题整理（附答案）

参考了[马三大佬的整理](https://github.com/XINCGer/Unity3DTraining/blob/master/Doc/马三的面试题整理.md)，进行补充并且将答案以我自己能理解的方式记录在此处



## Lua相关

### lua深拷贝和浅拷贝的区别？如何实现深拷贝？

一般来说，直接进行赋值的操作为浅拷贝，例如`a = 3; b = a`

对于值类型而言，浅拷贝操作会将a值复制一份交给a，a和b之间后续的数值变化不会互相影响

但对于引用类型而言，其存的是指针，后续对b进行修改时，a的值同样会受到影响

于是，我们需要用到深拷贝

在Lua中，共有8种数据类型，其中，bool、nil、number为值类型，数据不会互相影响；string较为特殊，虽然是引用类型，但每次修改都会创建一个新的副本，不会影响本体；function很难有什么操作会对其内容产生影响；thread和userdata较为特殊，一般不会做深拷贝的特殊处理；因此，对于深拷贝，我们只需要考虑table的做法即可

```lua
function table.copy(object)
    local lookup_table = {}
    local function _copy(object)
        if type(object) ~= 'table' then -- 非table类型都直接返回
            return object
        -- 避免本该是同一个table的属性，在复制时变成2个不同的table(内容同，但是地址关系和原来的不一样了)
        -- 例如key1和key2的值指向同一个table，此时复制后的表中，这两个值指向的table也得相同
        -- 同样也可以防止table中的某个属性为自身时出现死循环
        elseif lookup_table[object] then
            return lookup_table[object]
        end 
        local new_table = {}
        -- 已经复制过的table，key为复制源table，value为复制后的table
        lookup_table[object] = new_table
        for k,v in pairs(object) do
            new_table[_copy(k)] = _copy(v) 
        end 
        -- 这里直接拿mt来用是因为一般对table操作不会很粗暴的修改mt的相关内容
        return setmetatable(new_table, getmetatable(object))
    end 
    return _copy(object)                    
end
```



### lua中ipairs和pairs的区别？ 

ipairs：数组遍历，从索引为1的元素开始遍历，数值依次递增1，例如：遍历table[1], table[2], table[3]...直至nil值出现，停止遍历

pairs：全部遍历，优先进行数组遍历，然后对其余元素进行遍历

```lua
local a = {1, 2, 3, 4}
for _, v in ipairs(a) do
    print(v)
end
-- 返回1  2  3  4

a[3] = nil
for _, v in ipairs(a) do 
    print(v)
end
-- 返回1  2
```



### lua中的userdata是什么？有什么作用？  

https://blog.csdn.net/adam040606/article/details/56484488  

https://blog.csdn.net/zhang197093/article/details/77109674

如果lua想要使用C语言中的struct，就需要用到userdata，C语言可以根据结构体的大小开辟一块内存，并将其压入栈中，让Lua通过userdata进行读取



### 解释下lua中的元表元方法？

元表定义了一个表的行为，即针对各种操作该怎么处理，像是一个表的操作指南

而元方法则是声明对于具体的表操作该如何做处理

元表可以理解为是一系列元方法的集合

常用元方法如下：

```
__add(a, b) --加法
__sub(a, b) --减法
__mul(a, b) --乘法
__div(a, b) --除法
__mod(a, b) --取模
__pow(a, b) --乘幂
__unm(a) --相反数
__concat(a, b) --连接
__len(a) --长度
__eq(a, b) --相等
__lt(a, b) --小于
__le(a, b) --小于等于
__index(a, b) --索引查询
__newindex(a, b, c) --索引更新（PS：不懂的话，后面会有讲）
__call(a, ...) --执行方法调用
__tostring(a) --字符串输出
__metatable --保护元表
```

以`__index`为例

```
Table中访问一个元素时：
1. 在表中查找该元素，找到则返回，找不到则继续
2. 判断该表是否有元表，没有则返回nil，有则继续
3. 判断元表有无__index方法，没有则返回nil，有则继续
4. 如果__index是一个表，则在元表中重复上述操作，否则继续
5. 如果__index方法是一个函数则继续，否则报错
6. 调用该函数，调用时会传入目标table和查找的元素
```



### lua中如何实现面向对象？

lua中本身并不存在面向对象的特性，但是我们可以通过表和元表来模拟oop的语法

```lua
-- 基类
Rectangle = {area = 0, length = 0, breadth = 0}

-- 基类方法 new
function Rectangle:new (o,length,breadth)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    self.length = length or 0
    self.breadth = breadth or 0
    self.area = length*breadth
    return o
end

-- 基类方法 printArea
function Rectangle:printArea ()
    print("矩形面积为 ",self.area)
end

-- 创建对象
r = Rectangle:new(nil,10,20)

-- 访问属性
print(r.length)

-- 访问成员函数
r:printArea()

-- 派生类
Square = Rectangle:new(nil, 0, 0)

-- 派生类方法new
function Square:new(o, side)
    o = o or Rectangle:new(o, side, side)
    setmetatable(o, self)
    self.__index = self
    return o
end

-- 派生类方法printArea
function Square:printArea()
    print("正方形面积为 ", self.area)
end

-- 创建对象
s = Square:new(nil, 10)
s:printArea()
```



### 如何实现一个lua table的迭代器？

在泛型for循环中，包含了3个参数，迭代函数、状态常量、控制变量

我认为多状态和无状态的迭代器从逻辑上而言是一样的，只是多状态的迭代器由于状态较多，使用了局部变量和闭包，而无状态的迭代器是用for来保存状态的，因此，多状态的迭代器消耗更大，我们应尽可能使用无状态的迭代器

```lua
-- 无状态的迭代器
-- ipairs的实现
function iter (a, i)
    i = i + 1
    local v = a[i]
    if v then
       return i, v
    end
end
 
function ipairs (a)
    return iter, a, 0
end

-- 多状态的迭代器
array = {"Google", "Microsoft"}

function elementIterator (collection)
   local index = 0
   local count = #collection
   -- 闭包函数
   return function ()
      index = index + 1
      if index <= count
      then
         --  返回迭代器的当前元素
         return collection[index]
      end
   end
end

for element in elementIterator(array)
do
   print(element)
end
```



### lua和C++、C#交互原理？

 A:https://www.cnblogs.com/slysky/p/7919114.html  



### cstolua的底层原理？

A:https://www.cnblogs.com/msxh/p/9813147.html  



### C#与Lua交互原理?

 A:https://blog.csdn.net/UnityHUI/article/details/79752296  



### lua中的闭包？

```lua
function func1()
    local i = 100  --upvalue
    local func2 = function()
        i = i + 1
        return i
    end
    i = 101
    return func2
end

local f = func1()
print(f())    --输出102
print(f())    --输出103
```

如上所示，func1中返回了一个函数，这个函数会使用到func1中创建的一些局部变量，这便形成了一个闭包，在后续调用中，func1中声明的局部变量会被保留，可以理解为，闭包就是一个函数和它的执行环境，其中这些局部变量被称为UpValue



### 在lua中有俩字符串，内容都是"Hello"，说一下他们指向的内存空间是否是同一块？

https://blog.csdn.net/ft1874478a/article/details/95307214  

在5.1和5.3版本中，string的存储方式是不同的

在5.1中，所有字符串统一用stringtable存储，所有相同的string只存放一个哈希值用来索引stringtable

在5.3中，长度40以下的字符串用stringtable存储，而其他长字符串则和GCObject一样在内存中是单独一份数据拷贝



### lua是如何实现热更新的？

在lua中使用require进行模块的加载时，成功加载的模块会被保存在`package.loaded`这个表里，这样每次require时，会首先查看这个表，如果已经被加载过，则直接返回表中的值即可，否则就加载这个模块。如果想要重新加载某个模块，只要将表中的这个模块对应的值设定为nil即可



### Lua中的GC





## C#相关

### 值类型和引用类型的区别？

值类型确定大小，一般存放在栈上（也有存放在堆上的情况，比如int数组，以及一个特别大的struct，为了防止栈溢出，CLR可能就会将其存放在堆上），引用类型无法确定大小，存放在堆上，并且会在栈上存放一个指向堆上对象的指针，因此装箱就是给值类型分配堆空间的过程。其中会有一个比较特殊的引用类型，就是string，string对象是只读的，一旦创建就无法修改，所以每次改变值时都是创建一个新的string对象，然后让指针指向新的对象，建议用StringBuilder

值类型均继承自System.Value，其他均为引用类型，而引用类型均继承自System.object

传递值类型是复制数值，而传递引用类型是复制指针



### 堆和栈的区别？内存分配时地址有什么不同？

栈由操作系统自动分配，先进后出，执行效率很快，主要用于存储一些值类型数据和引用类型数据的指针，它们会受到程序运行的状态的影响，因此在栈上的成员一般存储周期非常短，因为它们在超出作用域之后就会被自动释放

堆是由GC进行托管，主要用于存储引用类型数据和大型的值类型数据，超出作用域的数据不会被释放，会由GC进行处理



### GC的原理？Unity中Mono的GC和.net原生的GC算法有什么区别？





### List\<T\>的底层实现原理？如何实现扩容？删除时占用内存空间会释放吗？



### String与StringBuilder的区别？StringBuilder底层原理？

A:https://www.cnblogs.com/oralig/p/7766566.html    



### C#中字符串的内存分配与暂存池?

A:https://blog.csdn.net/xiaouncle/article/details/87832198



### Dictionary的内部实现原理？

A:https://www.cnblogs.com/InCerry/p/10325290.html



### HashTable与Dictionary的区别？

A:https://blog.csdn.net/mpegfour/article/details/78725768



### 抽象类与接口的区别？什么时候使用抽象类，什么时候使用接口？



### C# 内存分配&&垃圾回收解析？

A:https://www.jianshu.com/p/53439af1eb00



### 谈谈.net对象生命周期

A:https://www.cnblogs.com/MaMaNongNong/p/11945161.html





## Unity相关

### 用过协程吗？应用场景是什么？协程与线程的区别？协程的底层实现原理？

应用场景：做一些动画、计时器或者延迟访问，比如网络请求等等。

进程是操作系统资源分配的基本单位，线程是处理器任务调度和执行的基本单位

进程拥有独立的堆和栈，而一个进程可以拥有多个线程，所有线程可以共享一些全局、静态变量，在多核CPU中，线程是可以并行的

而对于协程，协程属于线程，首先协程是不能并行的，协程并不是操作系统级别的，而是程序员可以显示地修改和调度的，假设我们开启了多个协程，在执行某一个协程的同时，其他协程是无法执行的，直到该协程遇到yield语句被挂起或关闭

协程本质上是Unity使用yield和迭代器做出来的，yield方法会将一个协程分为很多块，每次执行时，相当于是迭代器指针MoveNext向后移动了一个区域，程序将执行这一块区域中的代码，这种做法可以使协程可以被挂起，在不同的时间进行处理









### JIT、AOT是什么

CIL：即DotNet平台下的IL语言，IL是中间语言，是字节码（byte code），实际运行需要转换为对应平台的机器码

JIT：Just In Time，在运行过程中，将CIL转换为目标平台原生码，并加载进入内存执行的过程

AOT：程序运行之前就将CIL转换为目标平台原生码的过程



### IOS不支持JIT的原因

JIT的过程是，将IL字节码转换为IOS的机器码，并将其写入内存中执行的过程，但是在IOS中，转换后的机器码被禁止映射到内存中，因此我们无法使用JIT



### Mono和IL2CPP

Mono的目标是在尽可能多的平台上使满足DotNet标准的程序正常运行，它可以将C#代码转换为CIL，然后再将CIL转换为对应平台的机器码，其中需要Mono VM的帮助，即在不同平台运行CIL的虚拟机，这意味着Mono必须是JIT的，但对Unity而言，有多少个目标平台，就需要有多少个Mono VM，因此维护成本非常巨大，并且部分平台如WebGL、UWP是不支持JIT的

IL2CPP可以将IL转换为CPP文件，这样，通过各个平台的C++编译器，可以将代码转换为各个平台的机器码，因此IL2CPP只支持AOT，然后再通过IL2CPP VM执行即可，这里还需要用到虚拟机是因为即使代码已经变成了静态CPP文件，在内存管理方面，仍然遵循C#的帮助，比如GC管理、线程创建等工作，但这时已经去除了IL加载和动态解析的工作，因此虚拟机非常小，加载很快

对比一下，Mono支持JIT，并且构建更快，但IL2CPP运行效率更高







非托管内存

JobSystem